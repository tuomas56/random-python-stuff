import operator
from time import time
import pickle

TREE_ENGLISH_TEXT = 0
STATIC_TREES = [pickle.loads(b'\x80\x03G?\xf0\x00\x00\x00\x00\x00\x00G?\xda\x1bK\x14OjLG?\xc8\xd9\xfb)|\xd3\xf5G?\xb8\r\x82|\xc8E\xbeG?\xa6\xe9ha}1nG?\x96E\xd4\xa4\x1f\xf2\xdbX\x01\x00\x00\x00uq\x00\x86q\x01G?\x97\x8c\xfc\x1e\xdap\x01G?\x85\xe8[\xa5\xa1\x85\xf5X\x01\x00\x00\x00bq\x02\x86q\x03G?\x891\x9c\x98\x13Z\rG?w^?\x9f\x9b9\x8eG?e\xe8[\xa5\xa1\x85\xf5X\x01\x00\x00\x00Tq\x04\x86q\x05G?h\xd4#\x99\x94\xed&G?W^?\x9f\x9b9\x8eG?G^?\x9f\x9b9\x8eX\x01\x00\x00\x00Fq\x06\x86q\x07G?G^?\x9f\x9b9\x8eX\x01\x00\x00\x00Dq\x08\x86q\t\x86q\n\x86q\x0bG?ZJ\x07\x93\x8e\xa0\xbfX\x03\x00\x00\x00\xe2\x80\x99q\x0c\x86q\r\x86q\x0e\x86q\x0f\x86q\x10\x86q\x11G?{\x04\xf9\x90\x8bz\x8cG?jJ\x07\x93\x8e\xa0\xbfG?ZJ\x07\x93\x8e\xa0\xbfX\x01\x00\x00\x00Wq\x12\x86q\x13G?ZJ\x07\x93\x8e\xa0\xbfX\x01\x00\x00\x00Pq\x14\x86q\x15\x86q\x16\x86q\x17G?k\xbf\xeb\x8d\x88TXG?ZJ\x07\x93\x8e\xa0\xbfX\x01\x00\x00\x00Oq\x18\x86q\x19G?]5\xcf\x87\x82\x07\xf1X\x01\x00\x00\x00Iq\x1a\x86q\x1b\x86q\x1c\x86q\x1d\x86q\x1e\x86q\x1f\x86q \x86q!\x86q"\x86q#\x86q$\x86q%G?\xa91\x9c\x98\x13Z\rX\x01\x00\x00\x00hq&\x86q\'\x86q(\x86q)G?\xb9\xa6s\xd61b,X\x01\x00\x00\x00eq*\x86q+\x86q,\x86q-G?\xcb\\\x9a\xff"\x00\xa4G?\xbaU\xb6\xb3^n\\G?\xa9\xa6s\xd61b,X\x01\x00\x00\x00rq.\x86q/G?\xab\x04\xf9\x90\x8bz\x8cX\x01\x00\x00\x00oq0\x86q1\x86q2\x86q3G?\xbcc\x7fJ\xe5\x92\xebG?\xac4\xc2\xcb\xa6\\xX\x01\x00\x00\x00iq4\x86q5G?\xac\x92;\xca$\xc9^G?\x9ax\xc4\x12\xcd\xd72G?\x8aJ\x07\x93\x8e\xa0\xbfX\x01\x00\x00\x00gq6\x86q7G?\x8a\xa7\x80\x92\r\r\xa6X\x01\x00\x00\x00yq8\x86q9\x86q:\x86q;G?\x9e\xab\xb3\x81{\xbb\x8aG?\x8eN:\x82\xfdN\xa4G?}\xf0\xc1\x84~\xe1\xbeG?m5\xcf\x87\x82\x07\xf1G?]5\xcf\x87\x82\x07\xf1X\x01\x00\x00\x00Aq<\x86q=G?]5\xcf\x87\x82\x07\xf1X\x01\x00\x00\x00Cq>\x86q?\x86q@\x86qAG?n\xab\xb3\x81{\xbb\x8aX\x01\x00\x00\x00LqB\x86qC\x86qD\x86qEG?~\xab\xb3\x81{\xbb\x8aX\x01\x00\x00\x00kqF\x86qG\x86qH\x86qIG?\x8f\t,\x7f\xfa(pX\x01\x00\x00\x00wqJ\x86qK\x86qL\x86qM\x86qN\x86qO\x86qP\x86qQ\x86qR\x86qS\x86qT\x86qUG?\xe2\xf2Zu\xd8J\xdaG?\xd0\xe3\x1b\xfaW,\x98G?\xc0\x10\xcb\xbd\xba\xb7\x92G?\xaeN:\x82\xfdN\xa4X\x01\x00\x00\x00nqV\x86qWG?\xb0\xfaz9\xf6\xc7\xd1G?\xa0nD\xbc9$xG?\x90\x10\xcb\xbd\xba\xb7\x92G?~\xab\xb3\x81{\xbb\x8aX\x01\x00\x00\x00.qX\x86qYG?\x80\xcb\xbd\xba\xb7\x91^G?p\x10\xcb\xbd\xba\xb7\x91X\x01\x00\x00\x00BqZ\x86q[G?q\x86\xaf\xb7\xb4k*G?a\x86\xaf\xb7\xb4k*G?Q\x86\xaf\xb7\xb4k*X\x01\x00\x00\x00Mq\\\x86q]G?Q\x86\xaf\xb7\xb4k*X\x01\x00\x00\x00"q^\x86q_\x86q`\x86qaG?a\x86\xaf\xb7\xb4k*G?Q\x86\xaf\xb7\xb4k*G?A\x86\xaf\xb7\xb4k*X\x01\x00\x00\x00Qqb\x86qcG?A\x86\xaf\xb7\xb4k*X\x01\x00\x00\x00qqd\x86qe\x86qf\x86qgG?Q\x86\xaf\xb7\xb4k*G?A\x86\xaf\xb7\xb4k*X\x01\x00\x00\x00Gqh\x86qiG?A\x86\xaf\xb7\xb4k*X\x01\x00\x00\x00jqj\x86qk\x86ql\x86qm\x86qn\x86qo\x86qp\x86qq\x86qr\x86qs\x86qt\x86quG?\x90\xcb\xbd\xba\xb7\x91^X\x01\x00\x00\x00fqv\x86qw\x86qx\x86qyG?\xa1\x86\xaf\xb7\xb4k*G?\x90\xfaz9\xf6\xc7\xd1X\x01\x00\x00\x00mqz\x86q{G?\x92\x12\xe55r\x0e\x84X\x01\x00\x00\x00cq|\x86q}\x86q~\x86q\x7f\x86q\x80\x86q\x81\x86q\x82\x86q\x83G?\xc1\xb5l6\xf3\xa1\x9dG?\xb1\x11\xd8y\x96c\nX\x01\x00\x00\x00aq\x84\x86q\x85G?\xb2X\xff\xf4P\xe00G?\xa1\xe4(\xb62\xd8\x10X\x01\x00\x00\x00lq\x86\x86q\x87G?\xa2\xcd\xd72n\xe8PX\x01\x00\x00\x00dq\x88\x86q\x89\x86q\x8a\x86q\x8b\x86q\x8c\x86q\x8d\x86q\x8e\x86q\x8fG?\xd5\x01\x98\xf1Yi\x1dG?\xc3<\xd6\xe0\xa5\t\xa2G?\xb2d\xaf\x14 \xad\xcdX\x01\x00\x00\x00tq\x90\x86q\x91G?\xb4\x14\xfe\xad)evG?\xa4\x14\xfe\xad)evX\x01\x00\x00\x00sq\x92\x86q\x93G?\xa4\x14\xfe\xad)evG?\x93\x88\xc9/k\xc2\x1dG?\x82\xfc\x93\xb1\xae\x1e\xc4G?rA\xa1\xb4\xb1D\xf7X\x01\x00\x00\x00xq\x94\x86q\x95G?s\xb7\x85\xae\xaa\xf8\x90G?b\xfc\x93\xb1\xae\x1e\xc3G?Q\x86\xaf\xb7\xb4k*G?A\x86\xaf\xb7\xb4k*X\x01\x00\x00\x00-q\x96\x86q\x97G?A\x86\xaf\xb7\xb4k*X\x01\x00\x00\x00Eq\x98\x86q\x99\x86q\x9a\x86q\x9bG?Trw\xab\xa7\xd2\\X\x01\x00\x00\x00Vq\x9c\x86q\x9d\x86q\x9e\x86q\x9fG?drw\xab\xa7\xd2\\X\x01\x00\x00\x00Sq\xa0\x86q\xa1\x86q\xa2\x86q\xa3\x86q\xa4\x86q\xa5G?\x84\x14\xfe\xad)evX\x01\x00\x00\x00vq\xa6\x86q\xa7\x86q\xa8\x86q\xa9G?\x94\xa14*\xe7\x08\xcfG?\x84\x14\xfe\xad)evX\x01\x00\x00\x00pq\xaa\x86q\xabG?\x85-i\xa8\xa4\xac(X\x01\x00\x00\x00,q\xac\x86q\xad\x86q\xae\x86q\xaf\x86q\xb0\x86q\xb1\x86q\xb2\x86q\xb3\x86q\xb4\x86q\xb5G?\xc6\xc6[\x02\r\xc8\x98X\x01\x00\x00\x00 q\xb6\x86q\xb7\x86q\xb8\x86q\xb9\x86q\xba\x86q\xbb\x86q\xbc\x86q\xbd.')]

def generate_probs(data):
	probs = list(set([(data.count(item),item) for item in data]))
	probs = [(count/len(data),item) for count,item in probs]
	return probs

def generate_huffman_tree(probs):
	pqueue = []

	for item in probs:
		pqueue.append(item)
		pqueue.sort(key=operator.itemgetter(0))

	while len(pqueue) > 1:
		n1,n2,*pqueue = pqueue
		pqueue.append((n1[0] + n2[0],(n1,n2)))
		pqueue.sort(key=operator.itemgetter(0))
	return pqueue[0]

def get_symbol_prefix(tree,symbol):
	if tree[1] == symbol:
		return ''
	elif isinstance(tree[1],str):
		raise Exception()
	else:
		try:
			return '0' + get_symbol_prefix(tree[1][0],symbol)
		except:
			return '1' + get_symbol_prefix(tree[1][1],symbol)

def symbol_from_prefix(tree,prefix):
	for char in prefix:
		if char == '0':
			tree = tree[1][0]
		else:
			tree = tree[1][1]
	return tree

def pptree(tree,indent=0):
	if isinstance(tree[1],str):
		print("    "*indent + "(%.2f %s)" % tree)
	else:
		print("    "*indent + "(%.2f" % tree[0])
		pptree(tree[1][0],indent+1)
		pptree(tree[1][1],indent+1)

def encode_tree(tree):
	if isinstance(tree[1],str):
		return tree[1].encode('utf-8')
	else:
		return b'\x00' + encode_tree(tree[1][0]) + b'\x01' + encode_tree(tree[1][1])

def dynamic_huffman(data):
	before = time()
	probs = generate_probs(data)
	probstime = time() - before
	before = time()
	tree = generate_huffman_tree(probs)
	treetime = time() - before
	before = time()
	encoded = int(''.join([get_symbol_prefix(tree,symbol) for symbol in data]),2)
	encodingtime = time() - before
	encodedtree = encode_tree(tree)
	edata = encoded.to_bytes(((encoded.bit_length() + 7) // 8 + 1),'big')
	totaldata = len(edata).to_bytes(8,'big') + edata + len(encodedtree).to_bytes(8,'big') + encodedtree
	ratio = len(data)/len(totaldata)
	print("\nGenerating Tree\n==============")
	print("\nSymbol Probabilities:")
	for prob,symbol in probs:
		print("%.2f %s" % (prob,symbol))
	print("\nHuffman Tree:")
	pptree(tree)
	print("\nEncoding\n========")
	print("\nOriginal Payload:")
	print(data,len(data))
	print("\nEncoded Payload:")
	print(encoded,(encoded.bit_length() + 7) // 8 + 1)
	print("\nEncoded Tree:")
	print(encodedtree,len(encodedtree))
	print("\nTotal Encoded Data:")
	print(totaldata,len(totaldata))
	print("\nSummary\n=======")
	print("\nTime to generate probabilities: %.3f ms" % (probstime*1000))
	print("Time to generate tree: %.3f ms" % (treetime*1000))
	print("Time to encode data: %.3f ms" % (encodingtime*1000))
	print("Total time: %.3f ms" % ((probstime + treetime + encodingtime)*1000))
	print("%s%% compression (with tree).\n" % round(ratio*100))
	return totaldata

def static_huffman(data,treeno):
	tree = STATIC_TREES[treeno]
	before = time()
	encoded = int(''.join([get_symbol_prefix(tree,symbol) for symbol in data]),2)
	encodingtime = time() - before
	edata = encoded.to_bytes(((encoded.bit_length() + 7) // 8 + 1),'big')
	totaldata = bytes([treeno]) + len(edata).to_bytes(8,'big') + edata
	ratio = len(data)/len(totaldata)
	print("\nEncoding\n========")
	print("\nOriginal Payload:")
	print(data,len(data))
	print("\nEncoded Payload:")
	print(encoded,(encoded.bit_length() + 7) // 8 + 1)
	print("\nTotal Encoded Data:")
	print(totaldata,len(totaldata))
	print("\nSummary\n=======")
	print("\nTime to encode data: %.3f ms" % (encodingtime*1000))
	print("%s%% compression (with treeno).\n" % round(ratio*100))
	return totaldata

def raw_chunk(data):
	if isinstance(data,bytes):
		return len(data).to_bytes(8,'big') + data
	elif isinstance(data,str):
		data = data.encode('utf-8')
		return len(data).to_bytes(8,'big') + data
	elif isinstance(data,float) or isinstance(data,int):
		data = data.to_bytes(((data.bit_length() + 7) // 8 + 1),'big')
		return len(data).to_bytes(8,'big') + data
	else:
		data = pickle.dumps(data)
		return len(data).to_bytes(8,'big') + data